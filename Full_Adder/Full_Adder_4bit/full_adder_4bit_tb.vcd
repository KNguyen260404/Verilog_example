$date
	Mon Jun 23 13:44:30 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module full_adder_4bit_tb $end
$var wire 4 ! sum_signed [3:0] $end
$var wire 4 " sum [3:0] $end
$var wire 1 # overflow $end
$var wire 1 $ cout $end
$var reg 4 % a [3:0] $end
$var reg 4 & a_signed [3:0] $end
$var reg 4 ' b [3:0] $end
$var reg 4 ( b_signed [3:0] $end
$var reg 1 ) cin $end
$scope module uut $end
$var wire 4 * a [3:0] $end
$var wire 4 + b [3:0] $end
$var wire 1 ) cin $end
$var wire 1 # overflow $end
$var wire 4 , sum [3:0] $end
$var wire 1 $ cout $end
$var wire 1 - carry3 $end
$var wire 1 . carry2 $end
$var wire 1 / carry1 $end
$scope module fa1 $end
$var wire 1 0 a $end
$var wire 1 1 b $end
$var wire 1 ) cin $end
$var wire 1 / cout $end
$var wire 1 2 sum1 $end
$var wire 1 3 sum $end
$var wire 1 4 carry2 $end
$var wire 1 5 carry1 $end
$scope module ha1 $end
$var wire 1 0 a $end
$var wire 1 1 b $end
$var wire 1 5 carry $end
$var wire 1 2 sum $end
$upscope $end
$scope module ha2 $end
$var wire 1 2 a $end
$var wire 1 ) b $end
$var wire 1 4 carry $end
$var wire 1 3 sum $end
$upscope $end
$upscope $end
$scope module fa2 $end
$var wire 1 6 a $end
$var wire 1 7 b $end
$var wire 1 / cin $end
$var wire 1 . cout $end
$var wire 1 8 sum1 $end
$var wire 1 9 sum $end
$var wire 1 : carry2 $end
$var wire 1 ; carry1 $end
$scope module ha1 $end
$var wire 1 6 a $end
$var wire 1 7 b $end
$var wire 1 ; carry $end
$var wire 1 8 sum $end
$upscope $end
$scope module ha2 $end
$var wire 1 8 a $end
$var wire 1 / b $end
$var wire 1 : carry $end
$var wire 1 9 sum $end
$upscope $end
$upscope $end
$scope module fa3 $end
$var wire 1 < a $end
$var wire 1 = b $end
$var wire 1 . cin $end
$var wire 1 - cout $end
$var wire 1 > sum1 $end
$var wire 1 ? sum $end
$var wire 1 @ carry2 $end
$var wire 1 A carry1 $end
$scope module ha1 $end
$var wire 1 < a $end
$var wire 1 = b $end
$var wire 1 A carry $end
$var wire 1 > sum $end
$upscope $end
$scope module ha2 $end
$var wire 1 > a $end
$var wire 1 . b $end
$var wire 1 @ carry $end
$var wire 1 ? sum $end
$upscope $end
$upscope $end
$scope module fa4 $end
$var wire 1 B a $end
$var wire 1 C b $end
$var wire 1 - cin $end
$var wire 1 $ cout $end
$var wire 1 D sum1 $end
$var wire 1 E sum $end
$var wire 1 F carry2 $end
$var wire 1 G carry1 $end
$scope module ha1 $end
$var wire 1 B a $end
$var wire 1 C b $end
$var wire 1 G carry $end
$var wire 1 D sum $end
$upscope $end
$scope module ha2 $end
$var wire 1 D a $end
$var wire 1 - b $end
$var wire 1 F carry $end
$var wire 1 E sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
09
08
07
06
05
04
03
02
01
00
0/
0.
0-
b0 ,
b0 +
b0 *
0)
b0 (
b0 '
b0 &
b0 %
0$
0#
b0 "
b0 !
$end
#10
b10 !
b10 "
b10 ,
19
1/
15
11
10
b1 (
b1 &
b1 '
b1 +
b1 %
b1 *
#20
b11 !
b11 "
b11 ,
13
1)
#30
1#
1E
1-
1@
1.
0?
09
1:
b1000 !
b1000 "
b1000 ,
1>
18
03
1=
16
b101 (
b11 &
0)
b101 '
b101 +
b11 %
b11 *
#40
0=
1<
b1 (
b111 &
b1 '
b1 +
b111 %
b111 *
#50
b1110 !
b1110 "
b1110 ,
19
0:
1?
0@
1$
0#
08
1;
0>
1A
1G
17
1=
1C
1B
b1111 (
b1111 &
b1111 '
b1111 +
b1111 %
b1111 *
#60
b1111 !
b1111 "
b1111 ,
13
1)
#70
1#
09
0?
0E
0/
0.
0-
b0 !
b0 "
b0 ,
05
0;
0A
03
01
07
0=
00
06
0<
b1000 (
b1000 &
0)
b1000 '
b1000 +
b1000 %
b1000 *
#80
1F
1-
1@
1.
1:
b0 !
b0 "
b0 ,
1/
09
0?
0E
1$
0#
15
18
1>
1D
0G
11
10
16
1<
0B
b1001 (
b111 &
b1001 '
b1001 +
b111 %
b111 *
#90
